        risk_color = risk_palette.get(risk_level, (37, 99, 235))

        cards = [
            (_safe("??????? ?????" if ru else "Risk Level"), risk_level.upper(), risk_color),
            (_safe("???????????" if ru else "Probability"), f"{probability_pct:.1f}%", (37, 99, 235)),
            (_safe("?????????" if ru else "Audience"), f"{client_type} | {language}", (30, 41, 59))
        ]

        card_gap = 4
        card_width = (content_width - (card_gap * (len(cards) - 1))) / len(cards)
        card_height = 22
        card_y = pdf.get_y()
        for idx, (label, value, accent) in enumerate(cards):
            card_x = pdf.l_margin + idx * (card_width + card_gap)
            pdf.set_xy(card_x, card_y)
            pdf.set_fill_color(248, 250, 255)
            pdf.set_draw_color(226, 232, 240)
            pdf.rect(card_x, card_y, card_width, card_height, 'DF')

            pdf.set_xy(card_x + 4, card_y + 4)
            if unicode_ok:
                pdf.set_font('DejaVu', '', 9)
            else:
                pdf.set_font("Helvetica", "B", 9)
            pdf.set_text_color(100, 116, 139)
            pdf.cell(card_width - 8, 4, _safe(label.upper()))
            pdf.set_xy(card_x + 4, card_y + 10)
            if unicode_ok:
                pdf.set_font('DejaVu', '', 12)
            else:
                pdf.set_font("Helvetica", "B", 12)
            pdf.set_text_color(*accent)
            pdf.multi_cell(card_width - 8, 6, _safe(value))

        pdf.set_y(card_y + card_height + 8)
        pdf.set_text_color(30, 41, 59)
        if unicode_ok:
            pdf.set_font('DejaVu', '', 11)
        else:
            pdf.set_font("Helvetica", "", 11)
        para = (
            f"??????????: {prediction_text}. ??? ?????? ?????????? ???????????? ??????????, ???????????? SHAP ? ??????????? ?? ??? ????????? ???????."
            if ru else
            f"Prediction: {prediction_text}. This assessment combines laboratory analytics, SHAP explainability, and AI commentary to support clinical decision-making."
        )
        pdf.multi_cell(content_width, 6, _safe(para))
        pdf.ln(2)

        if unicode_ok:
            pdf.set_font('DejaVu', '', 13)
        else:
            pdf.set_font("Helvetica", "B", 13)
        pdf.cell(0, 9, _safe("???????????? ??????" if ru else "Laboratory Snapshot"), ln=True)
        if unicode_ok:
            pdf.set_font('DejaVu', '', 10.5)
        else:
            pdf.set_font("Helvetica", "", 10.5)

        feature_keys = ['wbc', 'rbc', 'plt', 'hgb', 'hct', 'mpv', 'pdw', 'mono', 'baso_abs', 'baso_pct', 'glucose', 'act', 'bilirubin']
        label_lang = 'ru' if str(analysis.get('language', 'en')).lower().startswith('ru') else 'en'
        lab_rows: list[tuple[str, str]] = []
        for key, label in zip(feature_keys, FEATURE_NAMES):
            raw_value = patient_inputs.get(key)
            try:
                formatted_value = f"{float(raw_value):.2f}"
            except (TypeError, ValueError):
                formatted_value = 'N/A' if raw_value is None else str(raw_value)
            lab_rows.append((label, formatted_value))

        row_fill = False
        row_height = 8
        for idx in range(0, len(lab_rows), 2):
            cells = lab_rows[idx:idx + 2]
            fill_color = (248, 250, 252) if row_fill else (255, 255, 255)
            pdf.set_fill_color(*fill_color)
            for col_idx in range(2):
                cell_width = content_width / 2
                if col_idx < len(cells):
                    label, value = cells[col_idx]
                    text = f"{label}: {value}"
                else:
                    text = ""
                pdf.cell(cell_width, row_height, _safe(text), border=0, ln=0 if col_idx == 0 else 1, fill=True)
            row_fill = not row_fill
        pdf.ln(2)

        shap_values = analysis.get('shap_values') or analysis.get('shapValues') or []
        if unicode_ok:
            pdf.set_font('DejaVu', '', 13)
        else:
            pdf.set_font("Helvetica", "B", 13)
        pdf.cell(0, 9, _safe("???????? ??????? SHAP" if ru else "Key SHAP Drivers"), ln=True)
        if unicode_ok:
            pdf.set_font('DejaVu', '', 11)
        else:
            pdf.set_font("Helvetica", "", 11)
        if shap_values:
            for idx, item in enumerate(shap_values[:5], start=1):
                feature = str(item.get('feature', 'Unknown'))
                label = FEATURE_LABELS.get(label_lang, FEATURE_LABELS['en']).get(feature.upper(), feature)
                impact = str(item.get('impact', 'neutral')).lower()
                value = item.get('value', 0)
                try:
                    value_str = f"{float(value):+.3f}"
                except (TypeError, ValueError):
                    value_str = str(value)
                pdf.multi_cell(content_width, 6, _safe(f"{idx}. {label} ({impact}): {value_str}"))
        else:
            pdf.multi_cell(content_width, 6, _safe("SHAP-?????? ??????????." if ru else "SHAP analysis unavailable."))
        pdf.ln(2)

        commentary = analysis.get('ai_explanation') or analysis.get('aiExplanation') or ''
        if commentary:
            if unicode_ok:
                pdf.set_font('DejaVu', '', 13)
            else:
                pdf.set_font("Helvetica", "B", 13)
            pdf.cell(0, 9, _safe("??????????? ?????? ??" if ru else "AI Clinical Commentary"), ln=True)
            if unicode_ok:
                pdf.set_font('DejaVu', '', 10.5)
            else:
                pdf.set_font("Helvetica", "", 10.5)
            pdf.set_fill_color(250, 253, 255)
            pdf.set_text_color(45, 55, 72)
            for paragraph in [segment.strip() for segment in commentary.split('\n') if segment.strip()]:
                pdf.multi_cell(content_width, 6, _safe(paragraph), border=0, fill=True)
                pdf.ln(1)
            pdf.set_text_color(30, 41, 59)
            pdf.ln(2)

        guideline_links = [
            ("NCCN v2.2024", "https://www.nccn.org/professionals/physician_gls/pdf/pancreatic.pdf"),
            ("ASCO 2023", "https://ascopubs.org/doi/full/10.1200/JCO.23.00000"),
            ("ESMO 2023", "https://www.esmo.org/guidelines/gastrointestinal-cancers/pancreatic-cancer"),
            ("CAPS 2020", "https://gut.bmj.com/content/69/1/7"),
            ("AGA 2020", "https://www.gastrojournal.org/article/S0016-5085(20)30094-6/fulltext")
        ]
        if unicode_ok:
            pdf.set_font('DejaVu', '', 12)
        else:
            pdf.set_font("Helvetica", "B", 12)
        pdf.cell(0, 8, _safe("?????? ?? ????????????" if ru else "Guideline References"), ln=True)
        if unicode_ok:
            pdf.set_font('DejaVu', '', 10)
        else:
            pdf.set_font("Helvetica", "", 10)
        pdf.set_text_color(37, 99, 235)
        bullet = '-'
        for label, url in guideline_links:
            pdf.cell(6, 6, _safe(bullet), ln=0)
            pdf.cell(0, 6, _safe(label), ln=1, link=url)
        pdf.set_text_color(30, 41, 59)
        pdf.ln(2)

        if unicode_ok:
            pdf.set_font('DejaVu', '', 9)
        else:
            pdf.set_font("Helvetica", "I", 9)
        pdf.set_text_color(100, 116, 139)
        pdf.multi_cell(
            content_width,
            5,
            _safe(
                "DiagnoAI Pancreas — ?????????? ????????? ?????????. ??????????????? ? ?????? ???????????? ????????? ? ??????????? ????????????."
                if ru else
                "DiagnoAI Pancreas provides AI-assisted screening support. Interpret alongside full clinical context and governing medical guidelines."
            )
        )

        pdf_bytes = bytes(pdf.output(dest='S'))
        buffer = BytesIO(pdf_bytes)
        buffer.seek(0)
        return buffer


# Bind top-level functions back to the class to maintain API
MedicalDiagnosticSystem.calculate_shap_analysis = calculate_shap_analysis
MedicalDiagnosticSystem._mock_shap_calculation = _mock_shap_calculation
MedicalDiagnosticSystem.generate_clinical_commentary = generate_clinical_commentary
MedicalDiagnosticSystem._generate_fallback_commentary = _generate_fallback_commentary
MedicalDiagnosticSystem._generate_ru_commentary = _generate_ru_commentary
MedicalDiagnosticSystem.guideline_snapshot = guideline_snapshot
MedicalDiagnosticSystem.generate_pdf_report = generate_pdf_report


# Clean Russian locale and labels override (ensures RU works correctly)
FEATURE_LABELS['ru_old_1'] = {
    'WBC': 'Ð›ÐµÐ¹ÐºÐ¾Ñ†Ð¸Ñ‚Ñ‹',
    'RBC': 'Ð­Ñ€Ð¸Ñ‚Ñ€Ð¾Ñ†Ð¸Ñ‚Ñ‹',
    'PLT': 'Ð¢Ñ€Ð¾Ð¼Ð±Ð¾Ñ†Ð¸Ñ‚Ñ‹',
    'HGB': 'Ð“ÐµÐ¼Ð¾Ð³Ð»Ð¾Ð±Ð¸Ð½',
    'HCT': 'Ð“ÐµÐ¼Ð°Ñ‚Ð¾ÐºÑ€Ð¸Ñ‚',
    'MPV': 'Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹ Ð¾Ð±ÑŠÐµÐ¼ Ñ‚Ñ€Ð¾Ð¼Ð±Ð¾Ñ†Ð¸Ñ‚Ð¾Ð²',
    'PDW': 'Ð¨Ð¸Ñ€Ð¸Ð½Ð° Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ñ‚Ñ€Ð¾Ð¼Ð±Ð¾Ñ†Ð¸Ñ‚Ð¾Ð²',
    'MONO': 'ÐœÐ¾Ð½Ð¾Ñ†Ð¸Ñ‚Ñ‹',
    'BASO_ABS': 'Ð‘Ð°Ð·Ð¾Ñ„Ð¸Ð»Ñ‹ (Ð°Ð±Ñ.)',
    'BASO_PCT': 'Ð‘Ð°Ð·Ð¾Ñ„Ð¸Ð»Ñ‹ (%)',
    'GLUCOSE': 'Ð“Ð»ÑŽÐºÐ¾Ð·Ð°',
    'ACT': 'ÐÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ ÑÐ²ÐµÑ€Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ',
    'BILIRUBIN': 'ÐžÐ±Ñ‰Ð¸Ð¹ Ð±Ð¸Ð»Ð¸Ñ€ÑƒÐ±Ð¸Ð½',
}
# RU feature label alias (final mapping is defined later)
# RU_FEATURE_LABELS = FEATURE_LABELS['ru']

# Deprecated duplicated RU mapping (superseded later)
COMMENTARY_LOCALE['ru_old_3'] = {
    'risk_labels': {'High': 'Ð’Ð«Ð¡ÐžÐšÐ˜Ð™', 'Moderate': 'Ð¡Ð Ð•Ð”ÐÐ˜Ð™', 'Low': 'ÐÐ˜Ð—ÐšÐ˜Ð™'},
    'probability_label': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ñ€Ð¸ÑÐºÐ°',
    'language_prompt': 'ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹Ñ‚Ðµ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼ ÑÐ·Ñ‹ÐºÐµ Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ñ‚Ð¾Ñ‡Ð½Ð¾Ð¹ ÐºÐ»Ð¸Ð½Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ñ‚ÐµÑ€Ð¼Ð¸Ð½Ð¾Ð»Ð¾Ð³Ð¸Ð¸.',
    'professional': {
        'header_template': 'ÐšÐ›Ð˜ÐÐ˜Ð§Ð•Ð¡ÐšÐžÐ• Ð”ÐžÐ¡Ð¬Ð• | {risk} Ð Ð˜Ð¡Ðš',
        'probability_label': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ñ€Ð¸ÑÐºÐ°',
        'drivers_title': 'ÐšÐ›Ð®Ð§Ð•Ð’Ð«Ð• Ð¤ÐÐšÐ¢ÐžÐ Ð«',
        'impact_terms': {
            'positive': 'Ð¿Ð¾Ð²Ñ‹ÑˆÐ°ÐµÑ‚ Ñ€Ð¸ÑÐº',
            'negative': 'ÑÐ½Ð¸Ð¶Ð°ÐµÑ‚ Ñ€Ð¸ÑÐº',
            'neutral': 'Ð½ÐµÐ¹Ñ‚Ñ€Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð²ÐºÐ»Ð°Ð´'
        },
        'default_driver': 'Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð±Ð¸Ð¾Ð¼Ð°Ñ€ÐºÐµÑ€ Ð² Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ñ… Ñ€ÐµÑ„ÐµÑ€ÐµÐ½ÑÐ°',
        'synopsis_title': 'Ð˜Ð¡Ð¡Ð›Ð•Ð”ÐžÐ’ÐÐ¢Ð•Ð›Ð¬Ð¡ÐšÐžÐ• Ð Ð•Ð—Ð®ÐœÐ•',
        'synopsis': {
            'High': 'ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ†Ð¸Ð¹ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð½Ð° Ð·Ð»Ð¾ÐºÐ°Ñ‡ÐµÑÑ‚Ð²ÐµÐ½Ð½ÑƒÑŽ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ. ÐŸÑ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚: Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ (ÐšÐ¢/ÐœÐ Ð¢ Ð¿Ð¾ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð»Ñƒ Ð¿Ð¾Ð´Ð¶ÐµÐ»ÑƒÐ´Ð¾Ñ‡Ð½Ð¾Ð¹), EUSâ€‘FNA Ð¿Ñ€Ð¸ Ð½ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸; Ð¾Ñ†ÐµÐ½ÐºÐ° ÑÐ¾Ð¿ÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ñ… Ñ€Ð¸ÑÐºÐ¾Ð² Ð¸ ÑÑ€Ð¾Ñ‡Ð½Ñ‹Ñ… Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼.',
            'Moderate': 'Ð¡Ð¼ÐµÑˆÐ°Ð½Ð½Ñ‹Ðµ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ†Ð¸Ð¸ Ð¸ Ð¿Ñ€Ð¾Ð¼ÐµÐ¶ÑƒÑ‚Ð¾Ñ‡Ð½Ð°Ñ Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ. ÐÑƒÐ¶Ð½Ð° ÑƒÑ‚Ð¾Ñ‡Ð½ÑÑŽÑ‰Ð°Ñ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¸ Ð´Ð¸Ð½Ð°Ð¼Ð¸ÐºÐ° Ð»Ð°Ð±Ð¾Ñ€Ð°Ñ‚Ð¾Ñ€Ð½Ñ‹Ñ… Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»ÐµÐ¹; ÑƒÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ Ð¿Ð°Ð½ÐºÑ€ÐµÐ°Ñ‚Ð¸Ñ‚, Ð´Ð¸Ð°Ð±ÐµÑ‚, ÐºÐ°Ñ…ÐµÐºÑÐ¸ÑŽ.',
            'Low': 'ÐÑ‚Ñ€Ð¸Ð±ÑƒÑ†Ð¸Ð¸ Ð±Ð»Ð¸Ð·ÐºÐ¸ Ðº Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¼; Ð½Ð¸Ð·ÐºÐ°Ñ Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ. Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ Ð½Ð°Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ðµ Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸ÐµÐ¼ ÐºÐ»Ð¸Ð½Ð¸Ñ‡ÐµÑÐºÐ¸Ñ… Ñ‚Ñ€Ð¸Ð³Ð³ÐµÑ€Ð¾Ð² Ð´Ð»Ñ Ñ€Ð°Ð½Ð½ÐµÐ³Ð¾ Ð¿ÐµÑ€ÐµÑÐ¼Ð¾Ñ‚Ñ€Ð°.'
        },
        'actions_title': 'Ð Ð•ÐšÐžÐœÐ•ÐÐ”Ð£Ð•ÐœÐ«Ð• Ð˜Ð¡Ð¡Ð›Ð•Ð”ÐžÐ’ÐÐÐ˜Ð¯',
        'actions': {
            'High': [
                'ÐšÐ¢/ÐœÐ Ð¢ Ð¿Ð¾ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð»Ñƒ Ð¿Ð¾Ð´Ð¶ÐµÐ»ÑƒÐ´Ð¾Ñ‡Ð½Ð¾Ð¹ Ð¶ÐµÐ»ÐµÐ·Ñ‹ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ 7 Ð´Ð½ÐµÐ¹.',
                'EUSâ€‘FNA Ð¿Ñ€Ð¸ Ð½ÐµÐ¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ð¾ Ð´Ð°Ð½Ð½Ñ‹Ð¼ ÐšÐ¢/ÐœÐ Ð¢.',
                'ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¼Ð°Ñ€ÐºÐµÑ€Ð¾Ð² (CA 19â€‘9, CEA) Ð¸ Ð¼ÐµÑ‚Ð°Ð±Ð¾Ð»Ð¸Ñ‡ÐµÑÐºÐ¸Ñ…/ÐºÐ¾Ð°Ð³ÑƒÐ»ÑÑ†Ð¸Ð¾Ð½Ð½Ñ‹Ñ… Ð¿Ð°Ð½ÐµÐ»ÐµÐ¹.'
            ],
            'Moderate': [
                'ÐÐ°Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÑŒ ÐšÐ¢/ÐœÐ Ð¢ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ 2â€“4 Ð½ÐµÐ´ÐµÐ»ÑŒ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ ÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸ÐºÐ¸.',
                'ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ñ‚ÑŒ Ð³Ð»Ð¸ÐºÐµÐ¼Ð¸ÑŽ Ð¸ Ð¼Ð°Ñ€ÐºÐµÑ€Ñ‹; ÑƒÑÐºÐ¾Ñ€Ð¸Ñ‚ÑŒ Ð¾Ð±ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¸ ÑƒÑ…ÑƒÐ´ÑˆÐµÐ½Ð¸Ð¸.'
            ],
            'Low': [
                'Ð ÑƒÑ‚Ð¸Ð½Ð½Ð¾Ðµ Ð½Ð°Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ðµ; Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ñ‹Ðµ Ð°Ð½Ð°Ð»Ð¸Ð·Ñ‹ Ð¿Ð¾ ÐºÐ»Ð¸Ð½Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½Ð¸ÑÐ¼.'
            ]
        },
        'coordination_title': 'ÐšÐžÐœÐœÐ£ÐÐ˜ÐšÐÐ¦Ð˜Ð¯ Ð˜ ÐÐÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð¯',
        'coordination': {
            'High': [
                'Ð¡Ð¾Ð³Ð»Ð°ÑÐ¾Ð²Ð°Ñ‚ÑŒ ÑÑ€Ð¾Ñ‡Ð½Ð¾Ðµ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ðº Ð³Ð°ÑÑ‚Ñ€Ð¾ÑÐ½Ñ‚ÐµÑ€Ð¾Ð»Ð¾Ð³Ñƒ/Ð¾Ð½ÐºÐ¾Ð»Ð¾Ð³Ñƒ.'
            ],
            'Moderate': [
                'ÐÐ°Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÑŒ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¸ÐµÐ¼ Ñ Ñ€Ð°Ð·Ð±Ð¾Ñ€Ð¾Ð¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð².'
            ],
            'Low': [
                'ÐŸÐ»Ð°Ð½Ð¾Ð²Ñ‹Ð¹ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒ Ð¿Ñ€Ð¸ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¸Ð¸ Ð½Ð¾Ð²Ñ‹Ñ… ÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ð¼Ð¾Ð².'
            ]
        },
        'monitoring_title': 'ÐœÐžÐÐ˜Ð¢ÐžÐ Ð˜ÐÐ“',
        'monitoring': {
            'High': [
                'ÐšÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒ ÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ð¼Ð¾Ð², Ð¶ÐµÐ»Ñ‚ÑƒÑ…Ð¸, Ð±Ð¾Ð»Ð¸, Ð¼Ð°ÑÑÑ‹ Ñ‚ÐµÐ»Ð°.'
            ],
            'Moderate': [
                'ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð½Ñ‹Ðµ Ð°Ð½Ð°Ð»Ð¸Ð·Ñ‹ Ð¸ Ð¾Ñ†ÐµÐ½ÐºÐ° Ð´Ð¸Ð½Ð°Ð¼Ð¸ÐºÐ¸.'
            ],
            'Low': [
                'Ð•Ð¶ÐµÐ³Ð¾Ð´Ð½Ð¾Ðµ Ð½Ð°Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ñ€Ð°Ð½ÑŒÑˆÐµ Ð¿Ñ€Ð¸ Ð¿Ð¾ÑÐ²Ð»ÐµÐ½Ð¸Ð¸ ÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ð¼Ð¾Ð².'
            ]
        },
        'reminder_title': 'Ð—ÐÐœÐ•Ð¢ÐšÐ',
        'reminder_text': 'Ð­Ñ‚Ð¾Ñ‚ Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð½Ðµ Ð·Ð°Ð¼ÐµÐ½ÑÐµÑ‚ ÐºÐ»Ð¸Ð½Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð² ÑÐ¾Ñ‡ÐµÑ‚Ð°Ð½Ð¸Ð¸ Ñ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð° Ð¸ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸.',
        'audience_guidance': 'ÐžÑÐ½Ð¾Ð²Ð½Ð°Ñ Ð°ÑƒÐ´Ð¸Ñ‚Ð¾Ñ€Ð¸Ñ: ÐºÐ»Ð¸Ð½Ð¸Ñ†Ð¸ÑÑ‚. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð¿Ñ€Ð¾Ñ„ÐµÑÑÐ¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ‚ÐµÑ€Ð¼Ð¸Ð½Ñ‹ Ð¸ ÐºÑ€Ð°Ñ‚ÐºÐ¸Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ³Ð¾ ÑˆÐ°Ð³Ð°.',
        'outline_template': (
            '{header}\n'
            '{probability_label}: <ÑƒÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð² %>\n\n'
            'ÐšÐ›Ð®Ð§Ð•Ð’Ð«Ð• Ð¤ÐÐšÐ¢ÐžÐ Ð«\n'
            '- ÐžÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ 3â€“5 Ð²ÐµÐ´ÑƒÑ‰Ð¸Ñ… Ñ„Ð°ÐºÑ‚Ð¾Ñ€Ð¾Ð² Ð¸ Ð¸Ñ… Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ.\n\n'
            'Ð Ð•Ð—Ð®ÐœÐ•\n'
            '- ÐšÑ€Ð°Ñ‚ÐºÐ¾ Ð¸Ð½Ñ‚ÐµÑ€Ð¿Ñ€ÐµÑ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ†Ð¸Ð¸ Ð¸ Ñ€Ð¸ÑÐºÐ¸.\n\n'
            'Ð Ð•ÐšÐžÐœÐ•ÐÐ”ÐÐ¦Ð˜Ð˜\n'
            '- ÐŸÐµÑ€ÐµÑ‡Ð¸ÑÐ»Ð¸Ñ‚Ðµ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ ÑˆÐ°Ð³Ð¸ Ð¸ ÑÑ€Ð¾ÐºÐ¸.'
        ),
    },
    'patient': {
        'header_template': 'Ð˜ÐÐ¤ÐžÐ ÐœÐÐ¦Ð˜ÐžÐÐÐÐ¯ Ð¡Ð’ÐžÐ”ÐšÐ | {risk} Ð Ð˜Ð¡Ðš',
        'probability_label': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ñ€Ð¸ÑÐºÐ°',
        'drivers_title': 'Ð§Ð¢Ðž Ð’Ð›Ð˜Ð¯Ð•Ð¢ Ð‘ÐžÐ›Ð¬Ð¨Ð• Ð’Ð¡Ð•Ð“Ðž',
        'impact_terms': {
            'positive': 'Ð¿Ð¾Ð²Ñ‹ÑˆÐ°ÐµÑ‚ Ñ€Ð¸ÑÐº',
            'negative': 'ÑÐ½Ð¸Ð¶Ð°ÐµÑ‚ Ñ€Ð¸ÑÐº',
            'neutral': 'Ð½ÐµÐ¹Ñ‚Ñ€Ð°Ð»ÑŒÐ½Ð¾'
        },
        'default_driver': 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»ÑŒ Ð² Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ñ… Ð½Ð¾Ñ€Ð¼Ñ‹',
        'core_title': 'Ð¡Ð£Ð¢Ð¬',
        'core_message': {
            'High': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾Ð²Ñ‹ÑˆÐµÐ½Ð°. ÐÑƒÐ¶Ð½Ñ‹ ÑƒÑ‚Ð¾Ñ‡Ð½ÑÑŽÑ‰Ð¸Ðµ Ð¾Ð±ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ (ÐšÐ¢/ÐœÐ Ð¢, EUSâ€‘FNA) Ð¸ Ð½Ð°Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ðµ Ð²Ñ€Ð°Ñ‡Ð°.',
            'Moderate': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð¼ÐµÐ¶ÑƒÑ‚Ð¾Ñ‡Ð½Ð°Ñ. Ð’Ñ€Ð°Ñ‡ Ñ€ÐµÑˆÐ¸Ñ‚, ÐºÐ°ÐºÐ¸Ðµ Ð°Ð½Ð°Ð»Ð¸Ð·Ñ‹ Ð¿Ð¾Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ Ð¿Ñ€Ð¾ÑÑÐ½Ð¸Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ð¸Ð½Ñƒ.',
            'Low': 'Ð’ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð½Ð¸Ð·ÐºÐ°Ñ. Ð”Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð¿Ð»Ð°Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð½Ð°Ð±Ð»ÑŽÐ´ÐµÐ½Ð¸Ñ Ð¸ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ñ Ðº ÑÐ¸Ð¼Ð¿Ñ‚Ð¾Ð¼Ð°Ð¼.'
        },
        'next_steps_title': 'Ð¡Ð›Ð•Ð”Ð£Ð®Ð©Ð˜Ð• Ð¨ÐÐ“Ð˜',
        'next_steps': {
            'High': ['Ð¡Ñ€Ð¾Ñ‡Ð½Ð¾ Ð¾Ð±ÑÑƒÐ´Ð¸Ñ‚Ðµ Ð¿Ð»Ð°Ð½ Ð¾Ð±ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ð¹ Ñ Ð²Ñ€Ð°Ñ‡Ð¾Ð¼.'],
            'Moderate': ['ÐÐ°Ð·Ð½Ð°Ñ‡ÑŒÑ‚Ðµ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒÐ½Ñ‹Ð¹ Ð²Ð¸Ð·Ð¸Ñ‚ Ð´Ð»Ñ Ð¾Ð±ÑÑƒÐ¶Ð´ÐµÐ½Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð².'],
            'Low': ['Ð¡Ð¾Ð±Ð»ÑŽÐ´Ð°Ð¹Ñ‚Ðµ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð²Ñ€Ð°Ñ‡Ð° Ð¸ Ð½Ð°Ð±Ð»ÑŽÐ´Ð°Ð¹Ñ‚Ðµ Ð·Ð° ÑÐ°Ð¼Ð¾Ñ‡ÑƒÐ²ÑÑ‚Ð²Ð¸ÐµÐ¼.']
        },
        'warnings_title': 'Ð¡Ð˜ÐœÐŸÐ¢ÐžÐœÐ« Ð¢Ð Ð•Ð’ÐžÐ“Ð˜',
        'warning_signs': ['Ð–ÐµÐ»Ñ‚ÑƒÑˆÐ½Ð¾ÑÑ‚ÑŒ ÐºÐ¾Ð¶Ð¸/ÑÐºÐ»ÐµÑ€', 'Ð¡Ð¸Ð»ÑŒÐ½Ð°Ñ Ð±Ð¾Ð»ÑŒ Ð² Ð¶Ð¸Ð²Ð¾Ñ‚Ðµ/ÑÐ¿Ð¸Ð½Ðµ', 'Ð¢ÐµÐ¼Ð½Ð°Ñ Ð¼Ð¾Ñ‡Ð°, ÑÐ²ÐµÑ‚Ð»Ñ‹Ð¹ ÑÑ‚ÑƒÐ»', 'Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ Ð¿Ð¾Ñ‚ÐµÑ€Ñ Ð²ÐµÑÐ°'],
        'support_title': 'ÐŸÐžÐ”Ð”Ð•Ð Ð–ÐšÐ',
        'support': ['ÐŸÐ¸Ñ‚Ð°Ð¹Ñ‚ÐµÑÑŒ Ð¸ Ð¾Ñ‚Ð´Ñ‹Ñ…Ð°Ð¹Ñ‚Ðµ Ð´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾', 'ÐžÐ±Ñ€Ð°Ñ‰Ð°Ð¹Ñ‚ÐµÑÑŒ Ð·Ð° Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¿Ñ€Ð¸ ÑƒÑ…ÑƒÐ´ÑˆÐµÐ½Ð¸Ð¸'],
        'reminder_title': 'ÐŸÐÐœÐ¯Ð¢ÐšÐ',
        'reminder_text': 'ÐŸÐ¾ÐºÐ°Ð¶Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ñ‚ Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð»ÐµÑ‡Ð°Ñ‰ÐµÐ¼Ñƒ Ð²Ñ€Ð°Ñ‡Ñƒ Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð½ÑÑ‚Ð¸Ñ Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹.'
    }
}


# Initialize diagnostic system

diagnostic_system = MedicalDiagnosticSystem()



def parse_patient_inputs(payload: Dict[str, Any]) -> tuple[list[float], Dict[str, float]]:

    """Convert incoming payload into feature list and normalized map."""

    features: list[float] = []

    normalized: Dict[str, float] = {}

    for key, default in FEATURE_DEFAULTS:

        raw_value = payload.get(key, default)

        try:

            value = float(raw_value)

        except (TypeError, ValueError) as exc:

            raise ValueError(str(exc)) from exc

        features.append(value)

        normalized[key] = value

    return features, normalized







def run_diagnostic_pipeline(payload: Dict[str, Any]) -> tuple[Dict[str, Any] | None, Dict[str, Any] | None, int]:

    """Execute the full diagnostic flow returning analysis data or an error payload."""

    try:

        features, normalized = parse_patient_inputs(payload)

    except (TypeError, ValueError) as exc:

        return None, {

            'error': 'Invalid numeric values in request data',

            'details': str(exc),

            'status': 'validation_error'

        }, 400



    is_valid, errors = diagnostic_system.validate_medical_data(normalized)

    if not is_valid:

        return None, {

            'error': 'Medical data validation failed',

            'validation_errors': errors,

            'status': 'validation_error'

        }, 400



    prediction, probability = diagnostic_system.predict_cancer_risk(features)

    shap_values = diagnostic_system.calculate_shap_analysis(features, prediction)

    language = str(payload.get('language', 'en')).lower()

    client_type = str(payload.get('client_type', 'patient') or 'patient').lower()

    ai_explanation = diagnostic_system.generate_clinical_commentary(

        prediction, probability, shap_values, features, language=language, client_type=client_type

    )
    # Avoid any re-encoding on RU text to prevent corruption
    if not str(language).lower().startswith('ru'):
        ai_explanation = repair_text_encoding(ai_explanation)



    analysis = {

        'prediction': int(prediction),

        'probability': float(probability),

        'risk_level': 'High' if probability > 0.7 else 'Moderate' if probability > 0.3 else 'Low',

        'shap_values': shap_values,

        'metrics': {k: v for k, v in diagnostic_system.model_metrics.items()},

        'ai_explanation': ai_explanation,

        'patient_values': normalized,

        'language': language,

        'client_type': client_type,

    }

    return analysis, None, 200





@app.route('/api/predict', methods=['POST'])
@rate_limit("10/minute")

def predict():

    """Professional pancreatic cancer prediction endpoint."""

    start_time = datetime.now()



    try:

        if not request.json:

            return jsonify({

                'error': 'No JSON data provided',

                'status': 'validation_error'

            }), 400



        data = request.json

        logger.info('Processing prediction request for patient data')



        analysis, error_payload, status_code = run_diagnostic_pipeline(data)

        if status_code != 200:

            return jsonify(error_payload), status_code



        processing_time = (datetime.now() - start_time).total_seconds()

        response = {

            **analysis,

            'processing_time': f"{processing_time:.3f}s",

            'timestamp': datetime.now().isoformat(),

            'status': 'success'

        }



        logger.info(f"Prediction completed: Risk Level {response['risk_level']}")

        return jsonify(response)



    except Exception as e:

        logger.error(f"Prediction error: {str(e)}")

        logger.error(f"Traceback: {traceback.format_exc()}")

