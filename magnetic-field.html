<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magnetic Field Lines</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: #05060a;
        overflow: hidden;
        font-family: "Space Grotesk", system-ui, -apple-system, sans-serif;
      }
      canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="field"></canvas>

    <script>
      /* ============================================================
       * Magnetic Field Lines â€” Canvas Background
       * Setup, interaction, noise, physics, and animation loop.
       * ============================================================ */

      const canvas = document.getElementById("field");
      const ctx = canvas.getContext("2d");

      const CONFIG = {
        particleCount: 900,
        baseSpeed: 0.35,
        maxSpeed: 1.1,
        fieldStrength: 2200,
        swirlStrength: 1600,
        noiseScale: 0.0012,
        noiseTimeScale: 0.00015,
        noiseStrength: 0.55,
        damping: 0.12,
        trailFade: 0.08,
        lineWidth: 0.9,
        dotRadius: 1.15,
        idleTimeout: 1200,
      };

      let width = 0;
      let height = 0;
      let dpr = 1;

      const pointer = {
        x: 0,
        y: 0,
        tx: 0,
        ty: 0,
        active: false,
        polarity: 1,
        lastMove: 0,
      };

      /* -------------------------- Noise (Simplex) -------------------------- */
      class SimplexNoise {
        constructor(seed = 1) {
          this.grad3 = [
            [1, 1, 0],
            [-1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [1, 0, 1],
            [-1, 0, 1],
            [1, 0, -1],
            [-1, 0, -1],
            [0, 1, 1],
            [0, -1, 1],
            [0, 1, -1],
            [0, -1, -1],
          ];
          this.p = new Uint8Array(256);
          for (let i = 0; i < 256; i += 1) this.p[i] = i;
          let n = seed;
          for (let i = 255; i > 0; i -= 1) {
            n = (n * 16807) % 2147483647;
            const r = n % (i + 1);
            const tmp = this.p[i];
            this.p[i] = this.p[r];
            this.p[r] = tmp;
          }
          this.perm = new Uint8Array(512);
          this.permMod12 = new Uint8Array(512);
          for (let i = 0; i < 512; i += 1) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
          }
        }

        noise3D(xin, yin, zin) {
          const grad3 = this.grad3;
          const permMod12 = this.permMod12;
          const perm = this.perm;
          const F3 = 1 / 3;
          const G3 = 1 / 6;

          let n0 = 0;
          let n1 = 0;
          let n2 = 0;
          let n3 = 0;

          const s = (xin + yin + zin) * F3;
          const i = Math.floor(xin + s);
          const j = Math.floor(yin + s);
          const k = Math.floor(zin + s);

          const t = (i + j + k) * G3;
          const X0 = i - t;
          const Y0 = j - t;
          const Z0 = k - t;
          const x0 = xin - X0;
          const y0 = yin - Y0;
          const z0 = zin - Z0;

          let i1 = 0;
          let j1 = 0;
          let k1 = 0;
          let i2 = 0;
          let j2 = 0;
          let k2 = 0;

          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            }
          } else {
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            }
          }

          const x1 = x0 - i1 + G3;
          const y1 = y0 - j1 + G3;
          const z1 = z0 - k1 + G3;
          const x2 = x0 - i2 + 2 * G3;
          const y2 = y0 - j2 + 2 * G3;
          const z2 = z0 - k2 + 2 * G3;
          const x3 = x0 - 1 + 3 * G3;
          const y3 = y0 - 1 + 3 * G3;
          const z3 = z0 - 1 + 3 * G3;

          const ii = i & 255;
          const jj = j & 255;
          const kk = k & 255;

          let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 > 0) {
            t0 *= t0;
            const gi0 = permMod12[ii + perm[jj + perm[kk]]];
            n0 = t0 * t0 * (grad3[gi0][0] * x0 + grad3[gi0][1] * y0 + grad3[gi0][2] * z0);
          }

          let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 > 0) {
            t1 *= t1;
            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]];
            n1 = t1 * t1 * (grad3[gi1][0] * x1 + grad3[gi1][1] * y1 + grad3[gi1][2] * z1);
          }

          let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 > 0) {
            t2 *= t2;
            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]];
            n2 = t2 * t2 * (grad3[gi2][0] * x2 + grad3[gi2][1] * y2 + grad3[gi2][2] * z2);
          }

          let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 > 0) {
            t3 *= t3;
            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]];
            n3 = t3 * t3 * (grad3[gi3][0] * x3 + grad3[gi3][1] * y3 + grad3[gi3][2] * z3);
          }

          return 32 * (n0 + n1 + n2 + n3);
        }
      }

      const noise = new SimplexNoise(42);

      /* ----------------------------- Particles ----------------------------- */
      const particles = [];

      const createParticle = () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 0.2,
        vy: (Math.random() - 0.5) * 0.2,
        speed: CONFIG.baseSpeed + Math.random() * 0.7,
      });

      const resetParticle = (p) => {
        p.x = Math.random() * width;
        p.y = Math.random() * height;
        p.vx = (Math.random() - 0.5) * 0.2;
        p.vy = (Math.random() - 0.5) * 0.2;
      };

      /* ------------------------------- Helpers ------------------------------ */
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const lerp = (a, b, t) => a + (b - a) * t;

      const resize = () => {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };

      /* ---------------------------- Interaction ---------------------------- */
      const onPointerMove = (event) => {
        pointer.tx = event.clientX;
        pointer.ty = event.clientY;
        pointer.active = true;
        pointer.lastMove = performance.now();
      };

      const onPointerDown = () => {
        pointer.polarity = -1;
        pointer.active = true;
        pointer.lastMove = performance.now();
      };

      const onPointerUp = () => {
        pointer.polarity = 1;
      };

      const onPointerLeave = () => {
        pointer.active = false;
      };

      window.addEventListener("mousemove", onPointerMove);
      window.addEventListener("mousedown", onPointerDown);
      window.addEventListener("mouseup", onPointerUp);
      window.addEventListener("mouseleave", onPointerLeave);
      window.addEventListener("blur", onPointerLeave);

      /* --------------------------- Field Calculation --------------------------- */
      const fieldAt = (x, y, time) => {
        let fx = 0;
        let fy = 0;

        if (pointer.active) {
          const dx = x - pointer.x;
          const dy = y - pointer.y;
          const distSq = dx * dx + dy * dy + 80;
          const dist = Math.sqrt(distSq);
          const inv = 1 / distSq;

          const radial = pointer.polarity;
          fx += (-dx / dist) * CONFIG.fieldStrength * radial * inv;
          fy += (-dy / dist) * CONFIG.fieldStrength * radial * inv;

          const tx = -dy / dist;
          const ty = dx / dist;
          fx += tx * CONFIG.swirlStrength * inv;
          fy += ty * CONFIG.swirlStrength * inv;
        }

        const n = noise.noise3D(
          x * CONFIG.noiseScale,
          y * CONFIG.noiseScale,
          time * CONFIG.noiseTimeScale,
        );
        const angle = n * Math.PI * 2;
        fx += Math.cos(angle) * CONFIG.noiseStrength;
        fy += Math.sin(angle) * CONFIG.noiseStrength;

        return { x: fx, y: fy };
      };

      /* ----------------------------- Animation ----------------------------- */
      let lastTime = performance.now();

      const animate = (time) => {
        const dt = Math.min(1, (time - lastTime) / 16.67);
        lastTime = time;

        if (time - pointer.lastMove > CONFIG.idleTimeout) {
          pointer.active = false;
        }

        pointer.x = lerp(pointer.x, pointer.tx || width / 2, 0.08);
        pointer.y = lerp(pointer.y, pointer.ty || height / 2, 0.08);

        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = `rgba(5, 6, 10, ${CONFIG.trailFade})`;
        ctx.fillRect(0, 0, width, height);

        ctx.globalCompositeOperation = "lighter";
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.strokeStyle = "rgba(120, 255, 220, 0.10)";
        ctx.shadowColor = "rgba(120, 255, 220, 0.25)";
        ctx.shadowBlur = 8;

        ctx.beginPath();
        for (let i = 0; i < particles.length; i += 1) {
          const p = particles[i];
          const prevX = p.x;
          const prevY = p.y;

          const field = fieldAt(p.x, p.y, time);
          const mag = Math.hypot(field.x, field.y) || 1;
          const vx = (field.x / mag) * clamp(p.speed, CONFIG.baseSpeed, CONFIG.maxSpeed);
          const vy = (field.y / mag) * clamp(p.speed, CONFIG.baseSpeed, CONFIG.maxSpeed);

          p.vx = lerp(p.vx, vx, CONFIG.damping);
          p.vy = lerp(p.vy, vy, CONFIG.damping);
          p.x += p.vx * dt;
          p.y += p.vy * dt;

          if (
            p.x < -50 ||
            p.x > width + 50 ||
            p.y < -50 ||
            p.y > height + 50
          ) {
            resetParticle(p);
          }

          ctx.moveTo(prevX, prevY);
          ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        ctx.shadowBlur = 10;
        ctx.fillStyle = "rgba(170, 255, 235, 0.55)";
        ctx.beginPath();
        for (let i = 0; i < particles.length; i += 1) {
          const p = particles[i];
          ctx.moveTo(p.x + CONFIG.dotRadius, p.y);
          ctx.arc(p.x, p.y, CONFIG.dotRadius, 0, Math.PI * 2);
        }
        ctx.fill();

        requestAnimationFrame(animate);
      };

      /* ------------------------------ Bootstrap ----------------------------- */
      const init = () => {
        resize();
        pointer.x = width / 2;
        pointer.y = height / 2;
        pointer.tx = pointer.x;
        pointer.ty = pointer.y;
        particles.length = 0;
        for (let i = 0; i < CONFIG.particleCount; i += 1) {
          particles.push(createParticle());
        }
        requestAnimationFrame(animate);
      };

      window.addEventListener("resize", resize);
      init();
    </script>
  </body>
</html>
